# PicoCTF 2023 Binary Exploitation: two-sum - 10Ô∏è0Ô∏è points

## two-sum Intro üöÄ

```
üìÅCategory: Binary Exploitation
üìÑFiles: flag.c (source)
üíªServer Connections: Yes
üè∑Ô∏èTags: C, make

üìÉDescription: What two positive numbers can make this possible: n1 > n1 + n2 OR n2 > n1 + n2

1Ô∏è‚É£Hint 1: Integer overflow
2Ô∏è‚É£Hint 2: Not necessarily a math problem
```

### Takeaways from hints, description, and tags: 
* We must perform integer overflow in order to obtain the flag
* The condition above with n1 and n2 must be satisfied
* This has less to do with math, and more to do with vulnerabilities
* We must gain control of n1 and n2
* Both n1 and n2 must be positive

## Playing with the Givens üïπÔ∏è
We are given source code and an address to a server which is running the source code as a compiled executable. Let's see if there is anything interesting about the source code or the connection. Maybe even give some imputs just to see its reaction.

`flag.c`
```c
#include <stdio.h>
#include <stdlib.h>

static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}

int main() {
    int num1, num2, sum;
    FILE *flag;
    char c;

    printf("n1 > n1 + n2 OR n2 > n1 + n2 \n");
    fflush(stdout);
    printf("What two positive numbers can make this possible: \n");
    fflush(stdout);
    
    if (scanf("%d", &num1) && scanf("%d", &num2)) {
        printf("You entered %d and %d\n", num1, num2);
        fflush(stdout);
        sum = num1 + num2;
        if (addIntOvf(sum, num1, num2) == 0) {
            printf("No overflow\n");
            fflush(stdout);
            exit(0);
        } else if (addIntOvf(sum, num1, num2) == -1) {
            printf("You have an integer overflow\n");
            fflush(stdout);
        }

        if (num1 > 0 || num2 > 0) {
            flag = fopen("flag.txt","r");
            if(flag == NULL){
                printf("flag not found: please run this on the server\n");
                fflush(stdout);
                exit(0);
            }
            char buf[60];
            fgets(buf, 59, flag);
            printf("YOUR FLAG IS: %s\n", buf);
            fflush(stdout);
            exit(0);
        }
    }
    return 0;
}
```

`server`
![image](https://github.com/shuban-789/PicoPwnbooks-BinaryExploitation/assets/67974101/ce64f9e6-bd6d-42ef-a2ad-8b9f31c9d5e7)

### What do we notice? 
* The code that in `addIntOvf()` has an apparent flaw in logic
* The returned numbers start becoming negative after a certain threshold


## Phase 2: Constructing a Plan üõ†Ô∏è
Using the information we have gathered, we can try to assess vulnerabilities on our target system. So far, we have thought of environment variable injection, but now it is time for us to plot out this plan.

### The Plan 
We make our own ls binary that spawns a shell. Since the file has an SUID, this will give us a root shell if the binary we are manipulating uses ls (in which according to the hints, it does).

There are however, some rather huge obstacles

```
Q: How would we execute this plan so that the binary we are manipulating thinks our ls binary is the real ls binary?

A: We could exploit the `PATH` environment variable. Many hints and tags tell us that the exploit has something to do
with environment variables and the ls executable which the SUID binary is most likely using for its operations.
```

```
Q: What directory should we put our binary into?

A: The answer is /tmp. A directory with read, write, and execute permissions for everyone. This is perfect as it will
be the perfect soil to plant our C code in.
```
### The Theory: 
When "ls" is typed into the command line, the system looks through path for an executable with the name "ls". So in our injected PATH, because `/tmp` is first, when the binary which runs ls as root runs "ls" as root it wil run our binary as root which will run /bin/bash root

![image](https://github.com/shuban-789/PicoPwnbooks-BinaryExploitation/assets/67974101/9525b700-e39d-4ec6-a2b6-62fe0edec152)


## Phase 3: Execution üßÄ
First, let's log onto our machine. To logon, we will need to use ssh with the command format of: 
`ssh -p <port> <user>@<ip>`
After logging on, let‚Äôs list our environment variables, and try editing the PATH

![image](https://github.com/shuban-789/PicoPwnbooks-BinaryExploitation/assets/67974101/64a60cc6-9cad-4ccb-bd9d-c21473fb51ae)

It looks like the injection worked, so we can move on to making our fake ls executable

Finally, we need to make our fake ls binary containing this C code:

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
  system("/bin/bash");
}
```

![image](https://github.com/shuban-789/PicoPwnbooks-BinaryExploitation/assets/67974101/a7a36a0b-8473-4114-bd49-09561a07b049)

Lets execute!

![image](https://github.com/shuban-789/PicoPwnbooks-BinaryExploitation/assets/67974101/984f1ed0-42e2-40c0-b297-5eb833df79e3)

### Disclaimer
The flag obtained in the command sequence example is obviously an edited version of the real flag. I highly reccomend you to try to solve the VNE problem and obtain its flag on your own. Happy Hacking! üßë‚Äçüíª

